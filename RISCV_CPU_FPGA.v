
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RISCV_CPU_FPGA(

    //////////// CLOCK //////////
    input 		          		FPGA_CLK1_50,
    input 		          		FPGA_CLK2_50,
    input 		          		FPGA_CLK3_50,

    //////////// HPS //////////
    inout 		          		HPS_CONV_USB_N,
    output		    [14:0]		HPS_DDR3_ADDR,
    output		     [2:0]		HPS_DDR3_BA,
    output		          		HPS_DDR3_CAS_N,
    output		          		HPS_DDR3_CKE,
    output		          		HPS_DDR3_CK_N,
    output		          		HPS_DDR3_CK_P,
    output		          		HPS_DDR3_CS_N,
    output		     [3:0]		HPS_DDR3_DM,
    inout 		    [31:0]		HPS_DDR3_DQ,
    inout 		     [3:0]		HPS_DDR3_DQS_N,
    inout 		     [3:0]		HPS_DDR3_DQS_P,
    output		          		HPS_DDR3_ODT,
    output		          		HPS_DDR3_RAS_N,
    output		          		HPS_DDR3_RESET_N,
    input 		          		HPS_DDR3_RZQ,
    output		          		HPS_DDR3_WE_N,

    //////////// KEY //////////
    input 		     [1:0]		KEY,

    //////////// LED //////////
    output		     [7:0]		LED,

    //////////// SW //////////
    input 		     [3:0]		SW
);



//=======================================================
//  SYSTEM : REG/WIRE declarations
//=======================================================

wire DDR3_CLK;
wire Debounce_KEY0;
wire Debounce_KEY1;

//=======================================================
//  SYSTEM : Structural coding
//=======================================================

soc_system u0 (
    //Clock&Reset
    .clk_clk                               ( FPGA_CLK1_50 ),      //    clk.clk
    .ddr3_clk_clk                          ( DDR3_CLK ),          //    clk_ddr3.clk

    //HPS ddr3
    .memory_mem_a                          ( HPS_DDR3_ADDR),      //    memory.mem_a
    .memory_mem_ba                         ( HPS_DDR3_BA),        //    .mem_ba
    .memory_mem_ck                         ( HPS_DDR3_CK_P),      //    .mem_ck
    .memory_mem_ck_n                       ( HPS_DDR3_CK_N),      //    .mem_ck_n
    .memory_mem_cke                        ( HPS_DDR3_CKE),       //    .mem_cke
    .memory_mem_cs_n                       ( HPS_DDR3_CS_N),      //    .mem_cs_n
    .memory_mem_ras_n                      ( HPS_DDR3_RAS_N),     //    .mem_ras_n
    .memory_mem_cas_n                      ( HPS_DDR3_CAS_N),     //    .mem_cas_n
    .memory_mem_we_n                       ( HPS_DDR3_WE_N),      //    .mem_we_n
    .memory_mem_reset_n                    ( HPS_DDR3_RESET_N),   //    .mem_reset_n
    .memory_mem_dq                         ( HPS_DDR3_DQ),        //    .mem_dq
    .memory_mem_dqs                        ( HPS_DDR3_DQS_P),     //    .mem_dqs
    .memory_mem_dqs_n                      ( HPS_DDR3_DQS_N),     //    .mem_dqs_n
    .memory_mem_odt                        ( HPS_DDR3_ODT),       //    .mem_odt
    .memory_mem_dm                         ( HPS_DDR3_DM),        //    .mem_dm
    .memory_oct_rzqin                      ( HPS_DDR3_RZQ),       //    .oct_rzqin

    .ddr3_hps_f2h_sdram0_clock_clk          (FPGA_CLK2_50),               // ddr3_0_hps_f2h_sdram0_clock.clk
    .ddr3_hps_f2h_sdram0_data_address       (ddr3_avl_address),       // ddr3_0_hps_f2h_sdram0_data.address
    .ddr3_hps_f2h_sdram0_data_read          (ddr3_avl_read),          // .read
    .ddr3_hps_f2h_sdram0_data_readdata      (ddr3_avl_readdata),      // .readdata
    .ddr3_hps_f2h_sdram0_data_write         (ddr3_avl_write),         // .write
    .ddr3_hps_f2h_sdram0_data_writedata     (ddr3_avl_writedata),     // .writedata
    .ddr3_hps_f2h_sdram0_data_readdatavalid (ddr3_avl_readdatavalid), // .readdatavalid
    .ddr3_hps_f2h_sdram0_data_waitrequest   (ddr3_avl_wait),          // .waitrequest
    .ddr3_hps_f2h_sdram0_data_byteenable    (16'hffff),               // .byteenable
    .ddr3_hps_f2h_sdram0_data_burstcount    (9'h1)                    // .burstcount
);

// Resets buttons
debounce d0(
  .clk(FPGA_CLK2_50), 		
  .reset_n(1'b1), 
  .idebounce(KEY[0]),
  .odebounce(Debounce_KEY0)  
);

debounce d1(
  .clk(FPGA_CLK2_50), 		
  .reset_n(1'b1), 
  .idebounce(KEY[1]),
  .odebounce(Debounce_KEY1)  
);

//=======================================================
//  CPU : REG/WIRE declarations
//=======================================================

wire [27:0] cpu_addr;
wire [31:0] cpu_data_out;
wire cpu_MemWrite;
wire cpu_MemRead;
wire [31:0] cpu_data_in;
wire cpu_pcEn;

//=======================================================
//  CPU : Structural coding
//=======================================================

assign cpu_pcEn = (cache_data_ready)? 1'b1 : 1'b0;
CPU_pipelined cpu (
    .iRST_n(Debounce_KEY0),
    .rom_clk(DDR3_CLK), 
    .clk(FPGA_CLK2_50),
    .pcEn(cpu_pcEn),

    .WB_ALUout(wb_data),
    .addr(cpu_addr),
    .data_out(cpu_data_out),
    .MemWrite(cpu_MemWrite),
    .MemRead(cpu_MemRead),
    .data_in(cpu_data_in)
);

//=======================================================
//  Cache : REG/WIRE declarations
//=======================================================

wire cpu_rw;
wire cpu_valid;
wire cache_data_ready;

wire cache_rw;
wire cache_valid;
wire cache_MemRead;
wire cache_MemWrite;

//=======================================================
//  Cache : Structural coding
//=======================================================

assign cpu_rw    = (cpu_MemWrite)?                1'b1 : 1'b0;
assign cpu_valid = (cpu_MemWrite || cpu_MemRead)? 1'b1 : 1'b0; 
cache_controller cc (
        .iCLK(FPGA_CLK2_50),
        // CPU --> Cache conterller (CPU request)
        .cpu2cache_addr(cpu_addr),
        .cpu2cache_rw(cpu_rw),
        .cpu2cache_valid(cpu_valid),
        .cpu2cache_data_in(cpu_data_out),
        // CPU <-- Cache controller (Cache result)
        .cache2cpu_data_out(cpu_data_in),
        .cache2cpu_ready(cache_data_ready),
        // Cache controller --> RAM (Memory request)
        .cache2mem_MemWrite(cache_MemWrite),
        .cache2mem_MemRead(cache_MemRead),
        // Cache controller <-- RAM (Memory result)
        .mem2cache_data_in(mem_data_out),
        .mem2cache_ready(data_ready)
);

//=======================================================
//  Memory Interface : REG/WIRE declarations
//=======================================================

wire [26:0]         aligned_address;
wire                ddr3_avl_wait;             //   .avl.waitrequest
wire [26:0]         ddr3_avl_address;          //   .address
wire                ddr3_avl_readdatavalid;    //   .readdatavalid
wire [127:0]        ddr3_avl_readdata;         //   .readdata
wire [127:0]        ddr3_avl_writedata;        //   .writedata
wire                ddr3_avl_read;             //   .read
wire                ddr3_avl_write;            //   .write
wire [DATA_W-1:0]   mem_data_out;
wire                data_received;
wire                data_ready;

reg [7:0]           LED_REG;

//=======================================================
//  Memory Interface : Structural coding
//=======================================================


// LEDs address  = 0x00 
// RAM addresses = 0x10 --> max address
// Min address from cpu to RAM must = 0x3FFFFF
// Max address from cpu to RAM must = 0x04 

assign LED = LED_REG;
assign aligned_address = (cpu_addr == 26'h00)? 27'h00 : cpu_addr + 27'hC;

always @(posedge DDR3_CLK, negedge Debounce_KEY0) begin
    // LEDs
    if (!Debounce_KEY0) begin
        LED_REG[7:0] <= 0;
    end
    else begin
        LED_REG[7] <= heart_beat[25] ;
        if (cpu_addr == 28'h00) begin
            if (cpu_MemWrite) begin
                LED_REG[6:0] <= cpu_data_out[6:0];
            end
        end
    end
end

 mem_interface mi(
		.iCLK(FPGA_CLK2_50),
		.iRST_n(Debounce_KEY0),
		
        // Avalon Interface
		.avl_wait(ddr3_avl_wait),                 
		.avl_address(ddr3_avl_address),                      
		.avl_readdatavalid(ddr3_avl_readdatavalid),                 
		.avl_readdata(ddr3_avl_readdata),                      
		.avl_writedata(ddr3_avl_writedata),                     
		.avl_read(ddr3_avl_read),                          
		.avl_write(ddr3_avl_write),

        // CPU
        .cpu_addr(aligned_address),
        .cpu_data_out(cpu_data_out),      // CPU --> mem_mangt --> avl.writedata
		.cpu_data_in(mem_data_out),        // CPU <-- mem_mangt <-- avl.readdata
        .cpu_MemRead(cache_MemRead),
        .cpu_MemWrite(cache_MemWrite),
        .value_received(value_received),
        .data_ready(data_ready)
);

//=======================================================
//  Heart beat
//=======================================================
reg [25:0] heart_beat;
// assign LED[7] = heart_beat[25];
always @(posedge FPGA_CLK2_50) begin
    heart_beat <= heart_beat + 1'b1;
end

// reg [3:0] state = 4'h0;
// reg [25:0] counter = 3'h0;

// always @(posedge FPGA_CLK2_50 or negedge Debounce_KEY0) begin
//     if (!Debounce_KEY0) begin
//         state <=  4'h0;
//         counter <= 25'h00;
//         // LED_REG[7:4] <= 0;
//     end else begin
//         counter <= counter + 1;
//         // if(ddr3_avl_readdatavalid) LED_REG[7:4] <= state;
//         if (cpu_pcEn)
//             case (state)
//                 0: begin
//                     cpu_MemWrite <= 1'b1;
//                     cpu_MemRead <= 1'b0;
//                     cpu_addr <= 26'h04;
//                     cpu_data_out <= 128'h05;
//                     state <= 1;
//                 end  
//                 1: begin
//                     cpu_MemWrite <= 1'b1;
//                     cpu_MemRead <= 1'b0;
//                     cpu_addr <= 26'h8;
//                     cpu_data_out <= 128'h0A;
//                     state <= 3;
//                 end
//                 2: begin
//                     state <= 3;
//                 end
//                 3: begin
//                     cpu_MemWrite <= 1'b0;
//                     cpu_MemRead <= 1'b1;
//                     cpu_addr <= 26'h8;
//                     state <= 4;
//                 end
//                 4: begin
//                     cpu_MemWrite <= 1'b0;
//                     cpu_MemRead <= 1'b0;
//                     data_buffer <= cpu_data_in;
//                     state <= 5;
//                 end  
//                 5: begin
//                     state <= 6;
//                 end 
//                 6: begin
//                     cpu_MemWrite <= 1'b1;
//                     cpu_MemRead <= 1'b0;
//                     cpu_addr <= 26'h00;
//                     cpu_data_out <= data_buffer;
//                     state <= 7;
//                 end
//                 7: begin
//                     cpu_MemWrite <= 1'b0;
//                     cpu_MemRead <= 1'b0;
//                 end
//             endcase
//     end
// end

endmodule
